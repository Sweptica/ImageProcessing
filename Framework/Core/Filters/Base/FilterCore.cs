using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Drawing;
using Framework.Core.Filters.Frequency;

namespace Framework.Core.Filters.Base
{
    /// <summary>
    /// Abstract class for implementing a filter.
    /// </summary>
    /// <remarks>
    /// This class handles conversions between different "image formats" in the moment of the execution
    /// of the filter by using overloads for the method ApplyFilter. Custom filter configurations should 
    /// be passed to the ApplyFilter method using a SortedDictionary; the default configurations should 
    /// be generated by overriding the GetDefaultConfigs() method. This class should not be inherited directly;
    /// use the class SpatialDomainFilter for spatial domain filter implementations or the 
    /// class FrequencyDomainFilter for frequency domain filter implementations instead. 
    /// </remarks>
    public abstract class FilterCore
    {

        /// <summary>
        /// Generate default configurations for the filter.
        /// </summary>
        /// <returns>Dictionary used to pass configuration though the 
        /// configs parameter of the method ApplyFilter. 
        /// null if there is the filter doesn't use configurations.</returns>
        public virtual SortedDictionary<string, object> GetDefaultConfigs()
        {
            return null;
        }

        // Put here all necessary overloads to make conversions (promotions, box/unboxing between types ...)
        
        /// <summary>
        /// Apply filter to a System.Drawing.Image.
        /// </summary>
        /// <param name="img"></param>
        /// <param name="configs"></param>
        /// <returns></returns>
        public virtual Image ApplyFilter(Image img, SortedDictionary<string, object> configs)
        {
            return Facilities.ToImage(
                    ApplyFilter(Facilities.ToBitmap(img), configs));
        }

        /// <summary>
        /// Apply filter to a System.Drawing.Bitmap.
        /// </summary>
        /// <param name="bitmap"></param>
        /// <param name="configs"></param>
        /// <returns></returns>
        public virtual Bitmap ApplyFilter(Bitmap bitmap, SortedDictionary<string, object> configs)
        {
            return Facilities.ToBitmap(
                    ApplyFilter(Facilities.ToColor(bitmap), configs));
        }

        /// <summary>
        /// Apply filter to a Color[,].
        /// </summary>
        /// <param name="colors"></param>
        /// <param name="configs"></param>
        /// <returns></returns>
        public virtual Color[,] ApplyFilter(Color[,] colors, SortedDictionary<string, object> configs)
        {
            byte[,] g = Facilities.To8bppGreyScale(colors);
            g = ApplyFilter(g, configs);

            return Facilities.ToRGBGreyScale(g);
        }

        // These are the methods that obligatory need to be implemented to make a filter:

        // To be implemented by spatial (, ***?) domain filters

        /// <summary>
        /// Apply filter to a byte[,]. Override to implement a filter in spatial domain.
        /// </summary>
        /// <param name="img"></param>
        /// <param name="configs"></param>
        /// <returns></returns>
        public abstract byte[,] ApplyFilter(byte[,] img, SortedDictionary<string, object> configs);

        // To be implemented by frequency domain filters

        /// <summary>
        /// Apply filter to a ComplexImage. Override to implement a filter in frequency domain.
        /// </summary>
        /// <param name="complexImg"></param>
        /// <param name="configs"></param>
        /// <returns></returns>
        public abstract ComplexImage ApplyFilter(ComplexImage complexImg, SortedDictionary<string, object> configs);

    }
}
